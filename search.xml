<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[强化学习超概括总结]]></title>
    <url>%2F2018%2F04%2F21%2FRL%2F</url>
    <content type="text"><![CDATA[前言Udacity深度学习的课程已经学到了最后，本来以为很快就可以做完最后一个项目完成课程。结果强化学习的内容比想象的要多的多，也深的多，花费了很长时间也没完成项目。本文将会概括我近期的学习内容，总结出强化学习的知识框架，以帮助我进一步学习。 强化学习要解决什么问题？一句话总结，强化学习要解决的问题和模糊系统（Fuzzy System）类似，都是复杂环境下的控制问题。 机器和人最大的不同在于人不需要知道知道具体的数值就可以做出动作或者决策，而机器不行。比如说走路，如果要让一个机器走路，实际上就是控制机器人各个关节施加的力，力的大小方向时机搭配合适了，机器人就能成功的走路了，但换一个路面这个搭配可能就不对了，需要重新调整。而人不需要这样，每个人都会走路，然而我们并不知道施加了多少力在关节上，甚至走路主要用到的是哪块肌肉都说不出来，但是人可以走各种各样的路。 有没有一种办法可以让机器人也能用人类的这种方式来做事，就是强化学习要解决的问题。 怎么解决？首先是把转化问题。在走路问题中，评价力的组合是好还是坏事困难的，]]></content>
      <categories>
        <category>知识总结</category>
      </categories>
      <tags>
        <tag>深度学习总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解卷积神经网络(CNN)——基础理论]]></title>
    <url>%2F2018%2F03%2F21%2FCNN%2F</url>
    <content type="text"><![CDATA[前言深度学习现在这么火热的一大原因就是卷积神经网络（以下简称CNN）在2012的ImageNet竞赛上取得了令人惊讶的进步，准确率提升了10%。所以专栏第一篇我想谈谈卷积神经网络。在学习卷积神经网络的过程中，我发现大部分资料集中在什么是卷积层，什么是Pooling层，怎么计算每层的输出尺寸，卷积层和Pooling层以什么形式叠加，这些问题上。这些资料虽然带我入了CNN的门，然而等我回过神来，我却发现我连为什么要使用CNN都答不上来。同时我产生了更多疑问，比如为什么要使用卷积层？为什么要使用Pooling层？为什么要这样堆叠不同的层？单一个因为他work是不能让我通体舒畅的。本文的目标是介绍CNN的基本结构，并在这个过程中穿插着我对上述问题的回答。我将从以下几个部分展开全文： 卷积神经网络在图像分类问题上有什么优势？ 为什么要使用卷积层？ 为什么要使用池化层？ 全连接层的作用 总结 PS：以下的讨论都是建立在一个已经训练好的CNN模型上的，本文不会讨论如何训练CNN网络，也不会分析CNN下的BP算法，比起这些如何理解CNN更加重要。 1. CNN在图像分类问题上有什么优势？现存问题和新方法的出现是一对孪生兄弟。在想不通CNN有什么优势的时候，把目光放在了之前研究的劣势上，无疑可以帮助我们缕清思绪。这里用水果分类来分析一下SVM以及神经网络的劣势。如果我们有一组水果的图片，里面有草莓，香蕉和橘子。在图片尺寸较大的情况下，使用SVM分类的步骤是 人工提取特征，比如说大小，形状，重量，颜色等。 根据上述特征，把每一张图片映射到空间中的一个点，空间的维度和特征的数量相等。 相同类别的物体具有类似的特征，所以空间中标记为草莓的点肯定是聚在一起的，香蕉和橘子也是同理。这时候使用SVM算法在空间中划出各类点之间的分界线就完成了分类。 在最后一步中，不使用SVM，用别的分类器也是可以的，比如KNN，贝叶斯，甚至神经网络都是可以的。虽然不同算法中性能会有差异，但是这里我想说的是在图像分类问题上的瓶颈并不在算法的性能上，而是在特征的提取上。区分草莓和橘子的特征是容易提取的，那橘子和橙子呢？如果上述四个特征不能很好的区分橘子和橙子，想要进一步提升算法的性能怎么办？通常的做法是需要提取新的特征。那么新特征应该如何选择呢？对于我这种水果盲来说，这个问题是具有一定难度的。除了橘子橙子问题，我们还有猫狗如何区分，狗品种如何识别等一系列问题。我想对于大部分人来说，狗狗品种的识别是非常有难度的。转了一圈回来，突然发现，图像分类任务的瓶颈竟然出现在特征选择上。（诚然目前有SIFT、HOG、LBP、LDP等自动提取特征的算法，但是效果并不理想，有局限性。）如果我们用神经网络直接对猫狗进行分类呢？这样不就避开了特征提取这一步了吗？假设输入图片大小为30×30，那么设置900个输入神经元，隐含层设置1000个神经元，输出神经元个数对应需要的输出数量不久好了吗？甚至用SVM也可以这样做，把一张30×30的图看作900维空间中的一个点，代表猫的点和代表狗的点在这个900维的空间中必然是相聚于两个簇，然后我们就又可以使用SVM来划出分界线了。但是这样计算开销就太大了，对于30×30的图片我们也许可以这样做，对于1000×1000的图片我们这样做的话就需要至少一百万个隐层神经元，这样我们就至少要更新 …emmmm…10^12个参数。而SVM的话，则相当于在一百万维的空间中运行了。运算量将会大的难以估计。另外，图片中并不是所有的信息都和是我们需要的。背景对我们的分类毫无价值，然而在这种一股脑全部拿来做输入的情况下，背景也被当成了特征进入了模型当中，准确度自然会有所下降。总之，如果不人工提取特征，那么计算量会非常大，精确度也无法保证。而人工提取特征的方式又会在某些问题下难以进行，比如狗狗品种分类。而CNN通过他独有的方式，成功解决了这两个问题。也就是说，CNN是一个可以自动提取特征，而且待训练参数相对不那么多的神经网络，这就是CNN在图像分类任务中的决定性优势。 2.为什么要使用卷积层？和神经网络模型类似，CNN的设计灵感同样来自于对神经细胞的研究。1981 年的诺贝尔医学奖，颁发给了 David Hubel、TorstenWiesel，以及 Roger Sperry。他们的主要贡献，是发现了人的视觉系统的信息处理是分级的。 从低级的V1区提取边缘特征，再到V2区的形状或者目标的部分等，再到更高层，整个目标、目标的行为等。也就是说高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。 值得注意的是，最低级的V1区需要提取边缘特征，而在上面提到的分类中，神经网络实际上是把30×30的图片按照900个像素点处理的。那么有没有一种方法能够让神经网络像人一样，按照边缘来理解呢？有的，这个方法就是卷积。卷积计算并不复杂，矩阵对应元素相乘的和就是卷积的结果，到了神经网络中会多出偏置b还有激活函数，具体方法如下图：图片源于Udacity深度学习纳米学位课程图片展示的是由九个权重组成的矩阵 $\left( \begin{array}{ccc}-1&amp;-1&amp;1\\ -1&amp;1&amp;-1\\1&amp;-1&amp;-1 \\ \end{array}\right)$ 和图片上九个像素点组成矩阵 $\left( \begin{array}{ccc} 0 &amp; 1 &amp; 1 \\ 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 \\ \end{array} \right)$ 进行卷积过程。在偏置b为0，激活函数使用ReLU的情况下，过程就像图片右下角的公式一样，对应元素乘积的和，再加上值为0的b，然后外套激活函数得到输出0。你可能会想这部分的计算和普通的神经网络没什么差别，形式都是$f(wx+b)$。那么这么处理和边缘有什么关系？多做几次卷积就知道了。图片源于Udacity深度学习纳米学位课程Filter指的是权重组成矩阵，Input Layer中存的是图片中的全部像素。Convolutional Layer存的是Filter与图片中所有3×3矩阵依次卷积后得到的结果。在输出中我们可以看到两个三，他们比其他的元素0都要大，是什么决定了卷积结果的大小？观察后发现，图中参与卷积的部分1的排列和活动窗口中1的排列完全一样时，输出为3。而像素的排列方式其实就是图片中的形状，这说明如果图像中的形状和Filter中的形状相似的话，输出值就大，不像就小。因此，卷积的操作建立了神经网络与图像边缘的联系。实际上CNN经过训练之后，Filter中就是图片的边缘啊，角落之类的特征。也就是说，卷积层是在自动提取图片中的特征。除此之外，卷积还有一种局部连接的思想在里面。它对图片的处理方式是一块一块的，并不是所有像素值一起处理，因此可以极大的降低参数值的总量。这里我需要使用那张经典的图片来说明卷积层是如何降低参数总量的：图片源于百度图片对于一张1000×1000的图片来说，对他进行分类，至少需要10的12次方个参数。而如果对图片使用卷积操作，每个神经元只和图像上的10×10的像素连接的话，参数总量就变成了10的8次方。但是这样的操作会导致一个问题，每个神经元只对应图片一部分的内容，那么这个神经元学到的内容就不能应用到其他神经元上。比如说有这样一个训练集，同样姿态的猫出现在黑色神经元负责的区域中，但是测试集中，猫可能出现在图片的任何位置。按照局部链接的做法，其他区域的猫是无法被正确识别的。而为了让出现在任何位置的猫都能够被正确识别，提出了权重共享。让红绿蓝黑神经元中的参数全都一样，这样就可以使得模型的准确率不受物体位置的影响，看起来就像同一个Filter滑过了整个图片。从提取特征的角度上来讲，一个Filter显然不能满足需求，因此需要生成多个不同的Filter来对图片进行卷积。更棒的是，为了获得平移不变性而使用的权重共享法，又意外的再一次降低了待训练参数总数。就算使用100个权值共享的10×10Filter来卷积，总参数也才10的4次方。也就是说，参数相较于普通的神经网络而言，总共下降了整整8个数量级，这种提升是夸张的。写到这里，卷积层的工作方式就已经全部出来了。具体工作流程如下图：图片源于百度图片蓝色的部分代表输入图像；绿色的部分代表输出矩阵；周围的虚线是padding操作，可以看作图像的一部分；下方不断移动的阴影就是Filter，其大小，数量，一次移动的距离都是可以自定义的；阴影至上方绿色的连线代表相乘再相加之后的结果输出到了输出矩阵的哪个位置。卷积层的这种操作方式，成功的模拟了生物视觉系统中的边缘特征提取部分。而CNN中对于分级结构的模拟，是通过卷积层的层层叠加实现的。AlexNet的论文中不止一次的提到，网络的深度对CNN性能的影响是显著的。可以认为卷积层的不断叠加会使得提取到的特征越来越复杂，整个流程就像上述引用中提到的人类的视觉系统的工作方式一样运行，最终完成对图片的分类。那么现在就可以很轻松的回答标题的问题了，使用卷积层是因为卷积层本质上是在自动提取图片的特征，而且在提取特征的同时，极大的降低了网络总体待训参数的总量。这两个特性使得CNN克服了特征提取困难，待训参数庞大的问题，成功制霸图片分类问题。 3.为什么要使用池化层你可能会问，卷积层就已经把参数降了下来，还解决了特征提取的问题，那还加一个池化层干什么呢？我认为，池化层只是工程上想让网络更深而做出的一个无奈之举。就以最经常出现的最大池化为例，来看看所谓的池化操作有多么随便吧。一个2×2的最大池化操作如上图，他做的就是把2×2窗口中的最大值存下来。所以绿色部分留下来了6；棕黄色部分是8；棕红色部分是3；蓝色部分是4。对，就是这么简单，就是这么随便。这个操作一眼看上去优点我没想出来，但是缺点却显而易见——损失了细节。为什么损失细节也要做这一步呢？我能想到的唯一的原因是要压缩矩阵，这样可以在模型中多加几层卷积层，用来提取更高维，更复杂的特征。而从压缩的角度上来看，这一步可谓简单有效，一个取最大值的操作，就让矩阵大小变为四分之一。AlexNet的出现是2012年，那时候用的是GTX580，3G显存，文章中提到只用一块GPU是不行的，因为显存会爆，因此用了两块GPU并行进行的这个任务。想必其作者也是苦于总是爆显存，而不得已加上的池化层。就算这样，还要用到两块GPU才成功训练了整个网络。然而池化层的应用似乎带来了更多的便利之处。由于其只取最大值，忽视掉了其他影响较小的值，所以在当内容发生很小的变化的时候包括一些平移旋转，CNN 仍然能够稳定识别对应内容。也就说池化层给模型带来了一定程度上的不变性。而应不应该使用池化层还是一个正在讨论的问题，有的网络用，有的网络不用。按照我的理解，在显存够用的情况下，不用池化层。这种丢失细节提升模型不变性的方法有一点七伤拳的意思。而且我们希望得到的模型并不是在不知道图片变化了的情况下可以得到正确的结果，我们希望的是模型可以认识到差异却依然能做出正确的分类才对。不过在以准确率为纲的今天，如果用池化层能提升准确率，就加上吧，无可厚非。 4.全连接层的作用在经过几次卷积和池化的操作之后，卷积神经网络的最后一步是全连接层。这一步就和最最普通的神经网络没有什么区别。我认为这里的神经网络就是充当一个分类器的作用，输入是不同特征的特征值，输出是分类。我甚至认为在训练好之后，把全连接层砍掉，把卷积部分的输出当作是特征，全连接换成SVM或者别的分类器，重新训练，也是可以取得良好效果的。 5.总结这里重新整理一下本文的内容： CNN之前的图片分类算法性能受制于特征的提取以及庞大参数数量导致的计算困难。 使用卷积来模拟人类视觉系统的工作方式，而这种方式极大的降低了神经网络的待训练参数数量。 为了获得平移不变性，使用了权重共享技术，该技术进一步降低了待训练参数数量。 卷积层实际上是在自动提取图片特征，解决了图像特征提取这一难题。 使用池化层的根本原因是降低计算量，而其带来的不变性并不是我们需要的。不过在以模型准确率为纲的大背景下，继续使用无可厚非。 全连接层实质上就是一个分类器。 6. 参考主要参考Udactiy深度学习纳米学位卷积神经网络部分，以及CS231n的相关内容写成。有任何疑问都欢迎在评论区指出。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>深入理解深度学习算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use python to implement Discrete Fourier transform]]></title>
    <url>%2F2018%2F01%2F30%2Fdft%2F</url>
    <content type="text"><![CDATA[In image processing, Discrete Fourier Transformation is a very useful method. However, its formula is so complicated that it is difficult to understand. As a result, I intend to deepen my understanding of it by implementing it. Since I am not familiar with c or c++, I use python to do this task. During the task, I realize that the efficiency of my method is not as good as I thought, so I use several methods to improve it. The goal of my work is implementing the Discrete Fourier Transformation(DFT) in the most efficient way in python. In this report, I would like to show my work in the following aspects: Introduction of Discrete Fourier Transformation. Introduction of my experiment. Implement the DFT with standard formula. Implement the DFT with Euler’s formula. Implement the DFT with matrix. The principle of Fast Fourier Transform(FFT). Conclusion. 1. Introduction of Discrete Fourier TransformationIn 1822, Fourier, a French scientist, pointed out that any periodic function can be expressed as a composition of sine and cosine in different frequencies. The posterity found that in some conditions, even non-periodic function can be expressed by sine and cosine. Following this idea, Fourier Transformation(FT) is produced. In image processing, the image data is discrete value. Based on the Fourier Transformation, Later researchers invent the Discrete Fourier Transformation(DFT) to hold the discrete value. Although the formula of FT and DFT is different, the principle of them is same. Therefore, we can use DFT to convert the image to a combine with sine and cosine. Even better, we could use the Inverse DFT to convert it back to image. As a result, DFT is very important in image processing. 2. Introduction to my experiment2.1 PurposeI aim to use python to implement the DFT in the most efficient way. In this report, I implement the DFT in different ways and I would give the comparison of them. 2.2 Programming environmentThe version of python is 3.6, IDE is jupyter notebook. In my program, I use three libraries. Opencv. I use this library to read image from folder. Numpy. I use this library to do matrix computing. Matplotlib. I use this library to show my results in picture. (If researches have the same version python with libraries that I mentioned before, they can copy my code to jupyter notebook and run it to check my work.) 2.3 Data preparationI prepare two different sizes of classic image Lena to test my program. One is the original image and its size is 512*512. The other is shrank image and its size is 50*50. Because the original image size is too large to do the test. Some of the algorithms will be too slow to get a result. Before the experiment, I read images from my folder. Here is code and explanations. I use function imread to read image and plt to show my results. Variable lena saves the information of the original lena and lena50 saves the information of the small sizes lena image. 12345678910import cv2import numpy as npimport mathimport matplotlib.pyplot as pltlena = cv2.imread("C:\lena.jpg",0) # read imagelena50 = cv2.imread("C:\lena50.jpg",0)plt.subplot(121),plt.imshow(lena,'gray'),plt.title('lena_512*512')plt.subplot(122),plt.imshow(lena50,'gray'),plt.title('lena_50*50')plt.show() 2.4 The steps of evaluating the result of method.I evaluate my result by following steps: Get result from my function. Get the standard answer from numpy’s fft funtion. Print out the result of each function. Check the picture to see whether they are same or not. Use allclose to check the result of my function whether correct or not. For each function, use timeit function to calculate the cost of time. 3. Implement the DFT with standard formula.3.1 How to implement it.The standard formula of the DFT is:$$F(u,v)= \sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi(ux/M+vy/N)}$$$f(x,y)$ means the pixel value. $M$ and $N$ is the length and width of the image$f(x,y)$. We can get several information from this formula: The output of Fourier Transformation is a complex matrix. Each pixel in the output is the sum of input pixel multiply a complicated formula. Based on these information, I start coding.First, I use the shape function get the row and column information from input image.Second, I build a complex matrix with same dimension of the input image.Finally, I use four loops to implement the Fourier Transformation. Here is the code: 12345678910def dft(input_img): rows = input_img.shape[0] cols = input_img.shape[1] output_img = np.zeros((rows,cols),complex) for m in range(0,rows): for n in range(0,cols): for x in range(0,rows): for y in range(0,cols): output_img[m][n] += input_img[x][y] * np.exp(-1j*2*math.pi*(m*x/rows+n*y/cols)) return output_img 3.2 Result123456789dft_lena50 = dft(lena50)out_dft = np.log(np.abs(dft_lena50))fft_lena50 = np.fft.fft2(lena50)out_fft = np.log(np.abs(fft_lena50))plt.subplot(121),plt.imshow(out_dft,'gray'),plt.title('dft_output')plt.subplot(122),plt.imshow(out_fft,'gray'),plt.title('np.fft_output')plt.show()np.allclose(dft_lena50,fft_lena50) True 12%timeit dft_lena50 = dft(lena50)%timeit fft_lena50 = np.fft.fft2(lena50) 26.3 s ± 574 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) 96.1 µs ± 1.98 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each) 3.3 Result analysisWe can see that the output image of dft is as same as the np.fft_output. And the result of np.allclose is true which means that each value in matrix dft_lena50 and fft_lena50 is equal. Therefore, I have already implemented the DFT. However,my method cost so much time. At the beginning, I use original image(size 512*512) to do the test and I even can not get the result. After changing the size of it, I can get result. It is still too slow. By using my function, it costs 26.3 seconds in average. But by using the function in numpy, it costs only 96.1 us in average. As a result, I figure out two ways to improve my code. First, I think that the exponential calculation in the loop will consume a lot of computing resources, so I use Euler’s formula to convert the exponent calculation into addition calculation. 4. Implement the DFT with Euler’s formula.4.1 How to implement it.I use Euler’s formula to change the exponent calculation into addition calculation. Than I get a new formula:$$F(u,v)= \sum_{x=0}^{M-1}\sum_{y=0}^{N-1}f(x,y)*(\cos(-2\pi(ux/M+vy/N))+j\sin(-2\pi(ux/M+vy/N)))$$Implement is very simple. I just change one row in dft then I get dft_ol function. 1234567891011def dft_ol(input_img): rows = input_img.shape[0] cols = input_img.shape[1] output_img = np.zeros((rows,cols),complex) for m in range(0,rows): for n in range(0,cols): for x in range(0,rows): for y in range(0,cols): w = -2*math.pi*(m*x/rows+n*y/cols) output_img[m][n] += input_img[x][y] * (math.cos(w) + 1j*math.sin(w)) return output_img 4.2 ResultThen, I did the same evaluation of it. Here is the result: 123456789dftol_lena50 = dft_ol(lena50)out_dftol = np.log(np.abs(dftol_lena50))fft_lena50 = np.fft.fft2(lena50)out_fft = np.log(np.abs(fft_lena50))plt.subplot(121),plt.imshow(out_dftol,'gray'),plt.title('dftol_output')plt.subplot(122),plt.imshow(out_fft,'gray'),plt.title('np.fft_output')plt.show()np.allclose(dftol_lena50,fft_lena50) True 12%timeit dftol_lena50 = dft_ol(lena50)%timeit fft_lena50 = np.fft.fft2(lena50) 21.8 s ± 84 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) 91.7 µs ± 855 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) 4.3 Result analysisWe could see that the result is correct. Although the average time is a little bit shorter than before(21.8s in average), it is still not acceptable. I think the problem is I used four loops in my code. In python, the efficiency of loop is low so I wander that is there any possibility to replace the loops? I check the formula again. The input of it is a matrix and the output of it is also a matrix. If we apply numpy library to do matrix computing, efficiency of calculating is high. Therefore I tried to write the formula in matrix way. 5. Implement the DFT with matrix.5.1 How to implement it.The image data is a two dimension matrix. Imply the DFT on two dimension data is a 2D-DFT problem. The 2D-DFT can write in two 1D-DFT:$$F(u,v)=\sum_{x=0}^{M-1}e^{-j2\pi ux/M}\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi vy/N}=\sum_{x=0}^{M-1}F(x,v)e^{-j2\pi ux/M}$$ $$F(x,v) =\sum_{y=0}^{N-1}f(x,y)e^{-j2\pi vy/N}$$ and the 1D-DFT is easy to write in matrix way:$$F(x,v) = M\vec x$$ $$M = e^{-j2\pi \vec v \vec y/N}$$ $\vec x $ means each row vectors of $f(x,y)$, $\vec v$ is a column vector $(0,1,2，\cdots，N-1)^T$,$\vec y$ is a row vector$(0,1,2，\cdots，N-1)$. For 2D-Fourier Transformation , we just need to do the 1D-DFT for each row of input and do 1D-DFT for each column of the output from 1D-DFT for rows. I follow this new formula building the dft_matrix function. 12345678910111213141516def dft_matrix(input_img): rows = input_img.shape[0] cols = input_img.shape[1] t = np.zeros((rows,cols),complex) output_img = np.zeros((rows,cols),complex) m = np.arange(rows) n = np.arange(cols) x = m.reshape((rows,1)) y = n.reshape((cols,1)) for row in range(0,rows): M1 = 1j*np.sin(-2*np.pi*y*n/cols) + np.cos(-2*np.pi*y*n/cols) t[row] = np.dot(M1, input_img[row]) for col in range(0,cols): M2 = 1j*np.sin(-2*np.pi*x*m/cols) + np.cos(-2*np.pi*x*m/cols) output_img[:,col] = np.dot(M2, t[:,col]) return output_img 5.2 ResultAlso, I use the same flow to evaluate it. Here is the result: 123456789dftma_lena50 = dft_matrix(lena50)out_dftma = np.log(np.abs(dftma_lena50))fft_lena50 = np.fft.fft2(lena50)out_fftma = np.log(np.abs(fft_lena50))plt.subplot(121),plt.imshow(out_dftma,'gray'),plt.title('dftma_output')plt.subplot(122),plt.imshow(out_fftma,'gray'),plt.title('np.fft_output')plt.show()np.allclose(dftma_lena50,fft_lena50) True 12%timeit dftma_lena50 = dft_matrix(lena50)%timeit fft_lena50 = np.fft.fft2(lena50) 10.9 ms ± 196 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 92 µs ± 523 ns per loop (mean ± std. dev. of 7 runs, 10000 loops each) The result is correct and the time is much shorter than other functions. It costs only 10.9ms in average. I think it is fast enough so I give the original lena as input and run it to see the result. 123456789dftma_lena = dft_matrix(lena)out_dftma = np.log(np.abs(dftma_lena))fft_lena = np.fft.fft2(lena)out_fftma = np.log(np.abs(fft_lena))plt.subplot(121),plt.imshow(out_dftma,'gray'),plt.title('dftma_output')plt.subplot(122),plt.imshow(out_fftma,'gray'),plt.title('np.fft_output')plt.show()np.allclose(dftma_lena,fft_lena) True 12%timeit dftma_lena = dft_matrix(lena)%timeit fft_lena = np.fft.fft2(lena) 16.3 s ± 448 ms per loop (mean ± std. dev. of 7 runs, 1 loop each) 11.3 ms ± 151 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 5.3 Result analysisThe result is correct but the time of calculation increase rapidly as the size of image increases. Although np.fft cost more time than before, it is not increase so rapidly. I check this online, the method that numpy used is called Fast Fourier Transformation(FFT). Since this function is not in the lecture so I did not implement it in my report but I studied its principle. 6. The principle of Fast Fourier Transform(FFT).Since we can use two 1D-DFT to calculate the 2D-DFT, we only to improve the efficiency of 1D-DFT than we can improve the efficiency of 2D-DFT. For a 1D-DFT:$$F(u)=\sum_{x=0}^{M-1}f(x)W_{M}^{ux}$$if M is divisible by 2, we can write it in two parts:$$M = 2K \F(u)=\sum_{x=0}^{K-1}f(2x)W_{K}^{ux} + \sum_{x=0}^{M-1}f(2x+1)W_{K}^{ux}W_{2K}^{ux}$$But in this formation the length of $F(u)$ is only a half as before. We need to calculate the other part of it:$$F(u+K) = \sum_{x=0}^{K-1}f(2x)W_{K}^{ux} - \sum_{x=0}^{M-1}f(2x+1)W_{K}^{ux}W_{2K}^{ux}$$This is called the symmetry of DFT. We only calculate half of DFT than we can got the result of whole DFT as soon as M is divisible by 2. Even better we can set $M=2^n$ , than we can divide the DFT into several small DFT and use the symmetry of DFT to reduce the amount of computation. This is the principle of FFT. Time complexity of FFT is $O(nlogn)$ , DFT is $O(n^2)$. Therefore, it is much faster than the DFT when the n is large. 7. Conclusion.Here is the result of all functions: Function name Input image Answer correct or not Time in average DFT with lecture’s formula Lena50 True 26.3 seconds DFT with Euler’s formula Lena50 True 21.8 seconds DFT with matrix Lena50 True 10.9 ms Numpy’s fft function Lena50 91.7 us DFT with matrix Lena True 16.3 seconds Numpy’s fft function Lena 11.3 ms As a result, I think the most efficient way to implement Discrete Fourier transform(DFT) in Python is use matrix to replace the loops. It is much faster than other method. However, the After this report, I feel I understand the Discrete Fourier Transform deeper than before. Here are the conclusion of this task: The Fourier transform converts the image to a superposition of sine and cosine. It is not intuitive to imagine an image is a superposition of sine and cosine. However, if we treat all the pictures as an instant noodles, understanding the concept of Fourier Transformation will be much more easier. Images is an instant noodles, sine and cosine is the noodle in noodles. The reason why we use Fourier transform is someone like thick noodle and others like the thin noodle. Fourier Transformation is a method that decomposition the instant noodles into one and one different noodle. Then we can choose the most appropriate noodle for different people. In image processing, it means that in some conditions, we may be interested in high frequency items and sometimes we may need the low frequency items. We can use the Fourier Transformation to find the desire items. In python, it is very important to learn how to use an appropriate library. In this task, I use the matrix to replace the loops in function. I use the numpy library to do the matrix computing. With this help, I reduce the time from 21.8 seconds to 10.9ms. If I use the numpy’s FFT function directly, only cost 91.7us. Therefore, the efficiency of the functions in python library is very high. It is much more practical to find a corresponding library function when encounter a problem. If we can’t find the corresponding library, it would be better to use others programming language to implement it such as C or C++. Because, without the help of library, python is too slow. 8. Reference[1] Gonzalez, Rafael C, &amp; Woods, Richard E. (1977). Digital image processing. Prentice Hall International, 28*(4), 484 - 486. [2] 快速傅里叶变换（FFT）算法【详解】]]></content>
      <categories>
        <category>Report</category>
      </categories>
      <tags>
        <tag>课程作业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解神经网络]]></title>
    <url>%2F2017%2F12%2F06%2FNN-1%2F</url>
    <content type="text"><![CDATA[前言神经网络(Neural Network)是一种模仿生物神经网络构造的数学模型。很多文章喜欢从生物的神经元结构方面入手，展开对人工神经网络的介绍。但那样会引入更多意味不明的单词，比如突触，树突，轴突……所以这里并不会深入的介绍生物的神经网络是怎么工作的，只会说明为什么人工神经网络要构造成这样。本文按照时间顺序依次介绍神经网络中的几个重要概念，并在当中穿插一些思考，大致分为以下几个部分： MP神经元 感知机 多层前馈神经网络 误差逆传播算法（BP算法） 总结 如果你对神经网络一无所知，本文会使得你对神经网络的来龙去脉有一些概念上的理解。如果你对神经网络有一定了解，本文的一些解释会让你对神经网络有豁然开朗的感觉。PS: 本篇文章需要你对线性回归和逻辑回归有一定了解，如果你不懂，我也针对这两个问题专门写了几篇文章，链接为：https://wasedamagina.github.io/archives/。 1. MP神经元MP神经元是神经网络的基本零部件，可以说神经网络就是神经元连接而成的网。理解神经网络，MP神经元是绕不开的。MP神经元模型在1943年就提出了，这是一个非常古老而经典的神经元模型，直到今天，我们仍然在使用这个神经元模型。MP神经元是模仿生物的神经元设计的：$x$ 模拟生物神经元中其他神经细胞给该细胞的刺激，值越大刺激越大；$w$ 模拟该细胞不同来源的刺激的敏感度；用阈值 $\theta$ 来描述激活该神经元的难易程度，越大越难激活；用 $w1x1+w2x2+……wnxn-\theta$ 来计算神经元的兴奋程度；$y=f(x)$ 为激活函数，用来计算神经元的输出；在MP神经元中，激活函数为阶梯函数。兴奋函数大于阈值输出1，小于阈值输出0；下图是MP神经元模型的示意图：图1.来源：《机器学习》——周志华 2. 感知机由于MP神经元的输入来自于其他神经元，我们显然不能指望单独一个神经元就有什么功能。而多个神经元可以组成不同的结构，其中有一个叫做感知机。感知机由输入和输出两层神经元组成，输入层有多个神经元，这些神经元只负责传递信号，没有任何其他功能；输出层只有一个MP神经元。这样的一个感知机可以用来做分类问题。比如说它可以把 $(0,0),(0,1),(1,0),(1,1)$ 四个点分为两类。输入是一个坐标，所以输入神经元要有两个，这样的感知机结构图如下：图2. 来源：《机器学习》——周志华$w1=0.6,w2=0.6,\theta=1$ 的感知机只在输入是 $(1,1)$ 的时候激活。如果把0理解为假，1理解为真，那么这个感知机的功能就和与门是一样的，只有两个输入都是真的时候，输出真。而图像上，这个感知机实际上是一条线，把 $(1,1)$ 分在一边，其他点分在另一边。图3. 来源：《机器学习》——周志华感知机的功能还挺强大的，才提出的时候，就可以用来对20×20像素的圆形，三角形以及正方形进行分类。那时候人工神经网络的研究可谓是风光无限，大量人员涌入，大量资本进入，就跟现在一样。但感知机有一个巨大的缺陷。如果你仔细观察计算兴奋度的式子，就会发现它和最普通的线性模型几乎一样，只不过概念上使用了生物学的神经元模型来包装而已。实际上，感知机确实对非线性划分问题无能为力。比如说异或计算问题：图4. 来源：《机器学习》——周志华无论如何改变参数的值，都无法完成异或计算，这是因为无法在平面上找到一条直线把$(0,1),(1,0)$与$(0,0),(1,1)$分为两类。所以说号称模拟生物神经元开发而来的人工MP神经元，连异或这种基本的非线性分类都做不到。这使得MP神经元的局限非常大，简直致命。而这个局限，被明斯基以一种充满敌意的方式呈现在了书中，直接导致神经网络的研究步入寒冬。 3. 多层前馈神经网络说实话，现在往回看，研究停滞这件事的出现多少有点不可思议。从生物学上来讲，绝大多数生物都拥有不止一个细胞，当单个MP神经元出现局限的时候，很自然的会想到在感知机的基础上加更多的神经元，看看是否会让感知机变得更加强大。从逻辑计算的角度上来讲，已知感知机可以实现与、或、非门。那么用多个感知机构造一个异或门，讲道理不是什么难事。而实际上只要在感知机的基础上再加一层神经元就可以进行异或的运算了。如下图：图5. 来源：《机器学习》——周志华上面的这个网络结构，箭头上的1和-1是权重$w$，大家可以把四个点带进去试试，确实可以成功的进行异或运算。而这种在感知机上多加一层神经元组成的网络，就是我们的主角——多层前馈神经网络，简称神经网络。功能上来看，这个神经网络已经足够强大了，不过这种结构下有两个问题是难以回答的：这网络是什么意思？参数如何训练？因为输出只有0和1，那么参数的变化并不一定会导致网络整体输出的变化。比如说，将上图的阈值0.5换为0.1甚至0.000001，他还是能够进行异或运算。这种改变了参数，输出却没有变化的情况，会对我们理解网络造成困难，进而导致模型训练困难。因为参数改变了结果也不变，那么在结果不理想的情况下，我们该如何调整参数？变大？还是变小？还是怎么办？这是一个问题。造成这个问题的原因是阶梯函数是一个不连续不可导的函数，用他作激活函数使得输出只有0，1两种，很僵硬。解决起来也简单，换一个激活函数就好。这里不能用线性函数，因为用线性函数作为激活函数的神经元，再多个，再多层，连接起来，最终网络的整体输出$Y$，一定可以写成一个关于输入$X$的线性函数。也就是说全部使用线性函数作为激活函数的神经网络，无论多少层都只是一个结构更加复杂的线性模型，实际功能上和感知机没有任何区别。那应该使用什么函数呢？首先线性是行不通了，那他起码是一个非线性函数。而阶梯函数这种的又会导致理解困难，所以他最好还是一个连续的函数。回顾过往的研究，我们恰好有一个这样的函数，他就是Sigmoid函数。该函数有非常多的优点，它非线性，连续，可导，导数好求，求出来的结果还不复杂。表达式如下：$$S(x)=\frac {1}{1+e^{-x}}$$现在我们把图5中所有神经元的激活函数都换成$Sigmoid$函数，它所呈现的结构就是多层前馈神经网络的基本结构了。下面给出多层前馈神经网络的具体解释：多层指的是：在输入层及输出层中间还有拥有激活函数的激活层，隐含层至少一层，也可以有多层，也就是说一个多层前馈神经网络最少有三层，多则没有上限。示意图如下：图6. 来源：《机器学习》——周志华上图中的 $\nu$代表隐层输入权重， $w$ 代表输出层输入权重，本文讨论的重点就是上图这种单隐含层神经元的网络，也叫三层神经网络。前馈指的是：由于该网络每层神经元与下一层神经元全互连，同层神经元之间不互连，也不会跨层连接，所以信息只会按照信息只能按照输入—&gt;隐藏—&gt;输出的方向传递，得名前馈。那么费劲半天，又是多加层神经元，又是寻找理想的激活函数，终于构造出这么个网络，有多牛逼？这些努力值得吗？非常值，有理论证明，一个具有有限数目神经元的单隐层多层前馈神经网络可以以任意精度逼近任意复杂度的连续函数。换句话说，单隐层神经网络可以学习任意连续函数。如果我们把生活的问题全都理解为函数，中译英其实就是输入中文，输出英文的函数；P图就是输入原图，输出美图的函数；语音识别就是输入语音，输出文字的函数；那么单隐层网络，理论上，可以解决这些问题。有多牛逼？大概就是为所欲为的那种程度的牛逼吧。理论很丰满，现实很骨干，这个理论上存在的参数该如何取得可是难为了人们好多年，直到BP算法的出现，训练的问题才算是找到了合理的解。 4. 误差逆传播算法（BP算法）4.1 为什么训练神经网络是一件难事？在介绍BP算法之前，我想先解释清楚为什么训练神经网络是一件难事。这对我们理解BP算法起到至关重要的作用。和训练线性模型一样，训练神经网络本质上也是要找到一组参数 $(W,\theta)$ ，使得代价函数最小。通常来讲，都是用梯度下降法来解决这个问题。既然是梯度下降，那就求参数偏导数不就可以解决了吗，Sigmoid导数性质那么好，这又什么难度？难度来自于神经网络的特殊结构。神经网络的全互联结构，使得神经网络有着数量庞大的参数总量，这无疑会降低网络训练速度。而神经网络的层级结构，使得它的输出y是一个复合了好几次的复合函数。如果我们直接求导，那么根据链式求导的规则，每一个参数的偏导数会写成一个看起来就很复杂的式子，中间不仅有乘法，有括号，还有求和符号 $\Sigma$ ，毫无疑问这样的公式算起来效率是很低的。所以问题不是别的，就是求各个参数的偏导太慢了。因此我们需要一个更加高效的方法来求偏导，而这个高效的方法就是BP算法。 4.2 如何理解BP算法？BP算法：英文名：Error Back Propagation。译文：误差逆传播算法。由于其缩写是BP算法，所以也有称这个为反向传播算法的。在解释BP算法为什么快之前，首先让我们回归问题本源：找到一组参数 $(W,\theta)$ 使得整体的输出值与实际值的误差最小。在这句话中默认了一个条件：有一组理想化的参数 $(W,\theta)$ 可以使得误差最小。而现在之所以有这么大的误差，就是因为目前这组 $(W,\theta)$ 和理想的 $(W,\theta)$ 之间不一样。但是整体上的认知并没有什么意义，我们想知道每一个参数偏差了多少，便于我们调整。说起来这个过程，特别像比赛结束后的分锅大会，赛后采访教练团说的“这次比赛失利是教练组和全体队员的失利”，这种结论是毫无营养的，观众更希望分锅到户。讨论如何分锅就必须要分析锅从何而来，整体分析是困难的，不妨从单独一个参数入手进行分析，比如说：在图6中，如果 $\nu_{1h}$ 的值与理想值不同，假设差异为 $\Delta\nu$ ，这里的误差会造成隐层第h个神经元的输出 $b_h$ 产生 $\frac{\partial b_h}{\partial \nu_{ih}}\Delta\nu$ 的误差。而 $b_h$ 又是所有输出层神经元的输入，所以会影响到所有输出层神经元的输出，最终造成总代价产生 $\frac{\partial CostFunction}{\partial \nu_{ih}}\Delta\nu$ 的误差。对于每个参数来说都是如此，本身的误差会它连接的神经元开始，一层一层的向前传递，传到输出层，最终导致代价函数的值产生变化。既然锅是一层一层的传过来的，那么在分锅的时候，就自然而然的会想到反向一层一层的把锅分回去。而每一层的误差确实可以用上一层（上指的是更靠近输出端）的误差来表示。我们只要从输出层开始往回一层一层捋，捋一遍就可以把锅分明白。这就是反向传播的基本思想。但是这和快速求导有什么关系？这是因为偏导数可以看成误差的度量。现在思考这样一个问题，已知一组 $(W,\theta)$ 的值，并且知道此时代价函数的值，我们可以人为的调整其中某个参数的值来降低代价，该怎样做？根据上面的式子 $\frac{\partial CostFunction}{\partial \nu_{ih}}\Delta\nu$ ，我们只需要将 $\Delta\nu$ 的符号与参数偏导的符号设置成相反的，就可以降低代价。在 $\Delta\nu$ 一定时，偏导数越大，代价变化越大，偏导数越小，代价变化越小。在这种情境下，我们可以把参数的偏导看作误差的度量。因为偏导越大，产生的误差就越大。所以说偏导数的计算也可以按照分锅的思路，从代价函数-&gt;输出层-&gt;隐层，一层一层反向传播，每一层的偏导数都用上一层的偏导数来表示，以此通过一次反向传播就把所有参数的偏导数都求解出来。这就是BP算法快速求导的原理。至于公式推导这里就不抄书了，有兴趣的可以看看《机器学习》中的推导。实际上关于BP算法还可以从编程的角度上来解释，把求导理解为寻路，说不定理解起来更加轻松，具体的解释知乎中就有，大家可以自行搜索。这里执意使用误差来解释，一是因为大部分学习资料没有覆盖到这种解释，而不解释的推导看起来和链式法则直接求导没有什么区别，这给BP算法的理解造成了不小的困扰；二是因为这种解释可以更深入的了解神经网络。比如说，都说梯度爆炸和消失会导致网络训练困难，但是这是为什么？而理解了误差，就可以解释了，因为梯度爆炸会导致该参数对代价函数产生极大的影响，而梯度消失则意味着该参数无法对代价函数产生影响。偏导数计算出来后，训练就是梯度下降法，这里的梯度下降和线性回归中的没什么区别，如果你对此不太了解，可以参照这个连接：https://wasedamagina.github.io/archives/。 5. 总结 MP神经元是神经网络的基本单元。 虽然感知机无法处理非线性问题，但是在感知机的基础上再加一层神经元就可以了。这种多层的结构，就是神经网络的雏形。 多层前馈神经网络指的是有至少一个隐含层，且每层神经元与下一层神经元全互连，同层神经元之间不互连，也不会跨层连接的神经网络。神经网络一般指代这种网络。 BP算法是一种快速求导的方法。 误差是一层一层向前传递的，所以也可以反向逐层表示。 可以把偏导数理解为误差的度量，按照误差逆传播的思想来逐层计算偏导数。 6. Reference[1] 周志华. 机器学习 : = Machine learning[M]. 清华大学出版社, 2016.[2] Michael A. Nielsen, “Neural Networks and Deep Learning”,Determination Press, 2015。]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>机器学习-原理讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逻辑回归(Logistic_Regression)]]></title>
    <url>%2F2017%2F11%2F23%2FLogistic-Regression%2F</url>
    <content type="text"><![CDATA[逻辑回归的由来线性回归能够做到具体值的预测，但实际生活中大家也有很多分类需求，比如说西瓜甜不甜，IPhoneX值不值得买，网线那头使劲卖萌的网友是萌妹还是大屌萌妹等。这时候线性回归就显得不那么灵活了。那么我们能不能通过稍微改进一下线性回归，使他可以进行分类呢？要做到这件事，首先需要一个函数把线性方程的值域映射到(0,1)。这样做有一个好处，就是函数的结果可以用来表示分类到1的概率，比如说计算结果是0.6，那就是说分类到1的概率为60%。那么这个函数最好可以在0.5附近变化最快，这样我们更不容易得到0.5附近的结果，使得看上去更可靠。最终人们找到了一个符合上述要求的函数——逻辑斯蒂函数(Logistic Function)，这大概就是逻辑回归的由来吧。 逻辑斯蒂函数(Logistic Function)该函数也叫Sigmoid函数，在神经网络中会再次提到。他的表达式如下：$$S(x)=\frac {1}{1+e^{-x}}$$他的图像如下： 可以看到满足上述性质。除此之外他还有一点好处，求导很容易：$$S^{‘}(x)=\frac {e^{-x}}{(1+e^{-x})^2}=\frac {1}{1+e^{-x}}(1-\frac {1}{1+e^{-x}})=S(x)(1-S(x))$$ 逻辑回归和线性回归一样，逻辑回归也是想找到一组最优的参数值，我们先写出逻辑回归的 $h_\theta(x)$ ：$$h_\theta(x)=S(\theta^Tx)=\frac {1}{1+e^{-\theta^Tx}}$$这个方程通过差的平方和来构造代价函数来求最小值是不太好用的，因为那是一个非凸函数，存在多个极值点，无论是使用梯度下降还是最小二乘法都有可能陷入局部最有解。因此我们使用极大似然估计来寻找那一组最优的参数值。那么首先我们需要表示出在参数$\theta$和输入x确定的条件下，y出现的概率。根据我们上文说的函数的结果可以用来表示分类到1的概率，我们可以写出下面两个式子：$$P(y=1|x;\theta)=h_\theta(x) \\P(y=0|x;\theta)=1-h_\theta(x)$$我们可以用一个小技巧将其合并在一起：$$p(y|x;\theta)=(h_\theta(x))^y(1-h_\theta(x))^{1-y}$$看起来很复杂，其实很简单。$y=1$时，后一半没了，得到式子1，$y=0$时，前一半没了得到式子2。 根据极大似然估计的思想，我们想要在参数$\theta$和输入x确定的条件下，所有样本的真实值y出现的概率越大越好，那么我们需要求一个联合概率，因为他们相互独立所以我们可以把所有y出现的概率连乘，得到likelihood函数：$$L(\theta)= \prod_{i=1}^{m}(h_\theta(x)^y(1-h_\theta(x))^{1-y}$$我们需要求上式的最大值，连乘的形式很难求，用$\log$函数转化为累加就比较好解决了：$$\begin{align}l(\theta)&amp;=\log L(\theta) \\&amp;=\sum_{i=1}^{m}y^{(i)}\log h_\theta(x^{(i)})+(1-y^{(i)})\log (1-h_\theta(x^{(i)}))\end{align}$$上式是一个凸函数，极值点就是最值点，而且可导，因此使用极大似然估计是优于差的平方和构造代价函数的。 我们求其对每一个$\theta$的偏导： $$\begin{align}\frac {\partial}{\partial\theta_j}l(\theta) &amp;=\sum_{i=1}^{m}(y^{(i)}\frac 1{ h_\theta(x^{(i)})}-(1-y^{(i)})\frac 1{ (1-h_\theta(x^{(i)}))})\frac {\partial}{\partial\theta_j}h_\theta(x^{(i)}) \\&amp;= \sum_{i=1}^{m}(y^{(i)}\frac 1{ h_\theta(x^{(i)})}-(1-y^{(i)})\frac 1{ (1-h_\theta(x^{(i)}))})h_\theta(x^{(i)})(1-h_\theta(x^{(i)}))\frac {\partial}{\partial\theta_j}\theta^Tx^{(i)} \\&amp;= \sum_{i=1}^{m}(y^{(i)}(1-h_\theta(x^{(i)}))-(1-y^{(i)})h_\theta(x^{(i)}))x_j^{(i)}\\&amp;= \sum_{i=1}^{m}(y^{(i)}-h_\theta(x^{(i)}))x_j^{(i)}\end{align}$$ 上面这个式子只是用了几次求导中的链式求导法则而已，属于高中数学，注意下 $$h_\theta(x)=S(\theta^Tx)=\frac {1}{1+e^{-\theta^Tx}}$$ 之后一步一步看，很容易看明白。 因为这里我们是求最大值，所以要用梯度上升而不是下降，每个$\theta$的更新法则如下：$$\theta_j:=\theta_j+\alpha \frac {\partial}{\partial\theta_j}l(\theta)=\theta_j+\alpha\sum_{i=1}^{m}(y^{(i)}-h_\theta(x^{(i)}))x^{(i)}_j$$重复上式，直到收敛，即可求得最大值，而使其取得最大值的$\theta$就是我们找的那一组最优的参数。 总结至此，逻辑回归的基本思想已经解释完毕。其实就是线性回归套上了一个逻辑斯蒂函数，把值域映射到了(0,1)之间而已。大部分的知识比如说极大似然估计，梯度上升法，都在线性回归中介绍过了。如果你看不懂这两个，可以去线性回归2和线性回归3中找答案。 最后，本人水平有限，机器学习也是才入门的水平，难免有谬误，欢迎大家指正。 Reference斯坦福机器学习公开课讲义note1 知乎-逻辑回归损失函数为什么使用最大似然估计而不用最小二乘法 zzanswer的回答]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>机器学习-原理讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归(3)——求最小值的两种方法]]></title>
    <url>%2F2017%2F11%2F21%2FLinear-Regression3%2F</url>
    <content type="text"><![CDATA[求$J(\theta)$最小值根据我们的假设，我们希望$J(\theta)$越小越好。求解$J(\theta)$的最小值，有两种方法，一种为梯度下降法，一种为最小二乘法。别看这两个名字都很不明觉厉，其实核心思想高中我们就学过——求导。 梯度下降法核心思想：因为x处的导数值为原函数在点(x,f(x))处切线的斜率，通过求导可以得到函数下降最快的方向，之后不断迭代，即可不断逼近函数的最小值。 对于上面这个例子来说，因为有多个$\theta$，我们需要对多个$\theta$求偏导，并按照下面的规则更新$\theta$值：$$\theta_j:=\theta_j-\alpha \frac {\partial}{\partial\theta_j}J(\theta)$$$\alpha$是学习率也叫步长，如果取值太大，容易跳过最小值，在最小值附近振荡。如果取值太小，会使得下降次数增多，导致收敛过慢。所以说步长这个别称还是挺有意思的，步子太小走得又慢，步子太大容易扯着蛋。 求偏导：$$\begin{align}\frac {\partial}{\partial\theta_j}J(\theta) &amp;=\frac {\partial}{\partial\theta_j}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2 \\&amp;= \sum_{i=1}^m2(h_\theta(x^{(i)})-y^{(i)})\frac {\partial}{\partial\theta_j}(h_\theta(x^{(i)})-y^{(i)}) \\&amp;= \sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)}) x_j\end{align}$$有了偏导值，我们可以简单的写出该问题下梯度下降法的步骤： 不断重复下面这个式子，用来更新$\theta$值，直到收敛。$$\theta_j=\theta_j-\alpha \sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)}) x_j$$ 最小二乘法核心思想：导数为0的地方为极值点，最小值就在那里。这里你可能会有疑问，导数为零的地方只是极值点，有可能是极大值，极小值，不一定是最小值。首先$J(\theta)$的形式决定了他只有最小值，没有最大值。其次$J(\theta)$是凸函数，所以他的局部极小值就是全局最小值。至于$J(\theta)$为什么是凸函数。。。我不知道，反正他就是。Andrew Ng说的。因为我们计算的$\theta$,$x$,$y$实际上都是矩阵，所以需要用到线性代数中求梯度的知识来计算，这部分我不打算细说，具体的推导步骤如下。 然后令导数得零，即可获得$\theta$的值。 总结线性回归因为内容比较多，分了三篇文章来叙述，现在已经基本说明白了，我们来总结一下： 线性回归由高尔顿提出，其思想是几乎所有的科学观察都着了魔似的向平均值回归。 线性回归的根本任务是确定一组参数，使得预测值和真实值之间的差异最小。 可以通过极大似然估计来论证为什么要使用差的平方和来描述预测值和真实值之间的差异。 极大似然估计认为对于给定的参数来说，最好的那一组应该是会让目前现存的所有样本出现概率最大的那组。 我们可以使用梯度下降和最小二乘法来求解损失函数的最小值。 梯度下降法的思想是过求导可以得到函数下降最快的方向，之后不断迭代，即可不断逼近函数的最小值。 最小二乘法的思想是导数为0的地方为极值点，最小值就在那里。 最后，本人水平有限，机器学习也是才入门的水平，难免有谬误，欢迎大家指正。 Reference《线性回归：机器学习史上最大命名错案》——机器学习入门微信公众号 斯坦福机器学习公开课讲义note1]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>机器学习-原理讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归(2)——代价函数]]></title>
    <url>%2F2017%2F11%2F21%2FLinear-Regression2%2F</url>
    <content type="text"><![CDATA[代价函数(cost function)上一篇文章我们说到，线性回归需要找到一条直线来拟合所有样本点，那么我们如何来判断他是否拟合了呢？我们需要将直线和样本点的偏差量化，用一个函数来表达，之后求其最小值，就可以得到我们想要的参数了。而这个函数就叫做代价函数(cost function)。 为了方便后面的分析，下面我需要使用斯坦福机器学习公开课中的例子来进行解释： Living area (feet2) bedrooms Price (1000$s) 2104 3 400 1600 3 330 2400 3 369 1416 2 232 3000 4 540 …… …… …… …… …… …… 上图是一组房屋的数据，包含了房屋大小，卧室数量，以及售价。问题是，想要根据房屋大小以及卧室的数量来预测其售价，那么首先我们可以用一个线性方程来定义售价： $$h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2$$ h是hypotheses的简写。如果我们设$x_0=1$，那么上式可以简写为： $$h(x)=\sum_{i=0}^{n}\theta_ix_i=\theta^Tx$$ 其中$n=2$，表示的是特征数量，如果加入了其他和房价相关的特征，比如说离学校的距离，离地铁的距离等其他特征，n的数值会变大，式子形式还是一样。$\theta^T$和$x$为矩阵。而整个线性回归问题，就是为了确定一组参数$\theta^T$使得预测值和真实值的差异最小。 我们使用差的平方和来计算预测值和真实值之间的差异，所有差异之和就可以用下式表示： $$J(\theta)=\sum_{i=1}^{m}(h_\theta(x^{(i)}) - y^{(i)})^2$$ 其中$h_\theta(x^{(i)})$代表第$i$个预测值，$y^{(i)}$代表第$i$个真实值。差异值最小，也就是$J(\theta)$最小。 这里大家可能会有疑问，为什么要用欧氏距离来计算差异？明明表示的是价钱差，直接相减取绝对值，不用平方不是可以更直观的表示吗？这个可以通过概率学来解释。 $J(\theta)$来历的解释$h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2$中的 $\theta_0$ 是误差，误差表示与特征无关的常量影响，或者是随机噪音。 $h_\theta(x)$ 可以写成下面的形式： $$y^{(i)}=\theta^Tx^{(i)}+\epsilon^{(i)}$$ 假设所有的$\epsilon^{(i)}$是独立同分布的，并且满服从均值为0，方差为$\sigma^2$的高斯分布。我们可以写出$\epsilon^{(i)}$的概率密度函数：$$p(\epsilon^{(i)})=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(\epsilon^{(i)})^2}{2\sigma^2}).$$我知道这个式子看起来一点也不简单，但是他实际上只是一个高斯分布的概率密度函数，如果你懂概率论那你一定不陌生，如果你不懂，没关系，暂时不去纠结为什么是这样，把他当作一个公式记住，并知道他描述的是概率就好。 因为$\epsilon^{(i)}=y^{(i)}-\theta^Tx^{(i)}$，把他带入，我们可以写出下面的表达式。$$p(y^{(i)}|x^{(i)};\theta)=\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2}).$$上式也是一个概率密度函数，描述的是对于给定的$\theta$和$x^{(i)}$，$y^{(i)}$出现的概率。 极大似然估计这个东西有什么用？我们回到问题的出发点，想要找到一组参数，使得方程可以拟合所有的样本点。那么对于给定的参数来说，最好的那一组参数应该是会让目前现存的所有样本出现概率最大的那一组，这就是极大似然估计的中心想法。我们将所有样本在该参数下的出现的概率连乘，就可以得到likelihood函数，写为下式： $$L(\theta)=\prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2}).$$ 目的是求出该函数的最大值，但是连乘问题不好解决，我们通过对数函数将其转化为连加来解决： $$\begin{align}l(\theta)&amp;=\log L(\theta) \\&amp;= \log \prod_{i=1}^{m}\frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})\\&amp;=\sum_{i=1}^{m}\log \frac{1}{\sqrt{2\pi}\sigma}\exp(-\frac{(y^{(i)}-\theta^Tx^{(i)})^2}{2\sigma^2})\\&amp;= m\log\frac{1}{\sqrt{2\pi}\sigma}-\frac{1}{2\sigma^2}\sum_{i=1}^{m}(y^{(i)}-\theta^Tx^{(i)})^2\end{align}$$ 这个式子看起来很复杂，其实只用了对数的运算法则而已，第二步用的是$\log mn=\log m + \log n$，第三步用的是$\log m^n=n\log m$。相信大家稍微看一下就能明白是怎么回事。 因为该式第一项是个常数，所以只要使得第二项最小，就可以使得整体最大。而第二项……那不就和$J(\theta)$一样吗？这也就解释了为什么代价函数是真实值与预测值的差的平方和。 总结本篇文章介绍了线性回归代价函数的由来，和最大似然估计法。由于本人水平有限，机器学习也是才入门的水平，难免有谬误，欢迎大家指正。 Reference《线性回归：机器学习史上最大命名错案》——机器学习入门微信公众号 斯坦福机器学习公开课讲义note1]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>机器学习-原理讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归(1)——起源]]></title>
    <url>%2F2017%2F11%2F13%2FLinear_Regression%2F</url>
    <content type="text"><![CDATA[几乎所有的科学观察都着了魔似的向平均值回归——《女士品茶》 什么是线性回归线性回归这个概念是由达尔文的表弟高尔顿在研究父代与子代身高关系的时候提出的，我第一次看到这四个字的时候，心中暗骂，这起的什么破名，一点都不直观。什么叫线性？什么叫回归？你在进行什么骚操作啊。然而这两个概念其实准确表达了该算法的核心思想，只要解释明白了这两个概念，我们就搞明白了线性回归。 线性高尔顿搜集了1078对父亲及其儿子的身高数据，用于研究其两者的关系，他画出了该组数据的散点图，发现这些样本点看起来分布在某条直线的周围，因此他使用一条直线来拟合这些样本点。 这也就是线性最初的意思：所有的样本点可以近似的用一条直线来表示。 回归高尔顿在画出直线后，对这些数据进行了深入的分析，最终发现了一个很有趣的现象。他发现当父亲高于平均身高时，他们的儿子更可能比他矮；而当父亲矮于平均身高时，他们的儿子身高更可能比他高。他称这种现象为回归现象。 参考上图： 只看x轴，我们可以简单的估计一下，父亲们的平均身高大概在68左右。然后看上图中标黄的部分，身高为64左右的父亲们，他们的儿子身高均值为67.1，普遍比父亲要高，向着均值68的方向贴近。再看绿色部分，身高为72左右的父亲们，儿子们的身高均值为70.9，普遍比父亲矮，向着均值68的方向贴近。 高尔顿将这种子代身高向着父辈的平均身高靠拢的现象称为回归效应。他还说，如果不向着均值的方向回归，高个子的后代更高，矮的更矮的话，用不了几代，我们人类就可以分裂成两个种族——巨人族和矮人族了。不仅身高如此， 几乎所有的科学观察都着了魔似的向平均值回归，这个世界观可以帮我们理解一些荒唐的问题：人类的身高不可能一直越来越高。人类的举重能力不可能越来越大。基因突变不会一直累积，所以变种人不会出现。行尸走肉里那种全球瘟疫不会发生。帅气的爷爷和爸爸，不一定有帅气的孙子。富不过三代。大自然（或者人类社会）以其神秘的力量和节奏调节着地球万物的秩序。——机器学习入门公众号 和机器学习有什么关系？最后高尔顿一通计算得到了拟合直线的表达式：$$y=33.73+0.516x$$其中x代表父辈的身高。 戏说：高尔顿把（33.73，0.516）这一对数字卖给算命先生A，告诉A，以后你也别算命了，支个摊子，叫算高先生，帮别人算孩子以后能长多高吧。让顾客告诉你他们的身高，然后代到上面的式子里算一下，结果就是他们孩子的身高。别说，这样算出来的结果虽然不百分百准确，但是八九不离十。因此A先生的算高摊子备受好评。 上面这个瞎编的故事，就是线性回归与机器学习的关系。线性回归是一种机器学习的方法，可以根据训练集（高尔顿收集的1078组身高数据）训练得到一组参数（33.73，0.516），之后利用该参数来预测结果（A先生做的事）。所以线性回归的根本问题就是通过已有训练集的数据，得到线性模型的一组参数。 总结我们总说机器学习机器学习，机器到底是从什么地方，学到了什么呢？线性回归这个特别基本的方法就很好的回答了这个问题——从一堆样本点里面学到了一组参数。我想这种直观的特点可以解释为什么几乎所有机器学习的书和教程上手的第一个算法是线性回归。 最后，本人水平有限，机器学习也是才入门的水平，难免有谬误，欢迎大家指正。 Reference《线性回归：机器学习史上最大命名错案》——机器学习入门微信公众号]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>机器学习-原理讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-Nearest Neighbor algorithm(KNN)]]></title>
    <url>%2F2017%2F11%2F12%2FKnn%2F</url>
    <content type="text"><![CDATA[近朱者赤，近墨者黑——《太子少傅箴》 什么是KNN算法KNN算法，全称K-Nearest Neighbor algorithm，直译就是K个最近的邻居算法，一般称为K最近邻法。这是一种属于监督学习的分类算法。 其中心思想用八个字就能概括：近朱者赤，近墨者黑。和原意有稍许不同，这里的近朱者赤近墨者黑是指；虽然我不知道你是红是黑，但我只要看你离红的近还是黑的近就好了，红近则为红，黑近则为黑。 生活中我们也常常用这样的方法认识他人。比如：因为小亮爸爸是混社会的，所以他一定也不是什么好人，不许和他玩；小明天天去台球厅和混混打台球，所以他一定也是不良少年；李磊的朋友都是韩梅梅和李华这种英语课本中的人物，所以他的英文肯定也非常好。这种根据A周围人的属性，来推断A属性的思想，就是KNN算法的核心思想。用更加正式一点的表达就是： 给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例，这K个实例多数属于哪类，就认为输入实例分类属于哪类。 KNN算法的关键KNN算法的思想非常容易理解，但若我们现在就开始上手编程实现KNN，就会遇到下面两个问题： 什么叫离得近？怎么判断新来的实例和训练数据集中实例的邻近程度？ 所谓的K个实例，到底是几个实例？为什么是个变量而不是最近的一个？ 这两个问题同样也是KNN算法的核心问题，会极大的影响KNN算法的性能。 远近？距离！描述远近？这不就是距离干的事吗？而数学上有多种距离定义，其中最常用的是欧氏距离。你可能没听说过这个名字，但是你一定用过下面这个公式：$$|AB|=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$高中时代这个公式叫两点间距离公式，其实就是欧氏距离公式在二维空间的形式（维度的概念在线性回归中再细说，这里就简单的理解为下标的最大值就好）。对于两个n维向量，$x=(x_1,x_2,…,x_n)$,$y=(y_1,y_2,…,y_n)$他们之间的欧式距离为：$$d(x,y)=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+…+(x_n-y_n)^2}$$还有很多种其他距离，比如曼哈顿距离、切比雪夫距离、汉明距离等，这里就不一一介绍了，只是对于距离计算的方式不同而已，有兴趣的可以自己上网查一下。 为什么取K个实例？K值如何确定？因为KNN算法的分类结果随K取值的不同会发生变化，下图简单的说明这一问题： 红色和蓝色为已知训练集中的两个不同分类，现在来了一个新的输入，想要判断绿圆是属于红三角还是蓝方块。在K=3时，最近的3个实例中，有两个红三角，一个蓝方块，红三角比较多，所以新输入应该属于红三角。而K=5时，最近的5个实例中，有三个蓝方块，两个红三角，蓝方块比较多，所以新输入应该属于蓝方块。不同的K值使得KNN的分类结果不同了，这种不同最后会使得KNN的分类准确率也不同，所以找到一个最合适的K值是很关键的。 实际操作中，K值的确定往往使用交叉验证的方法，说白了就是试出来的。将训练集分20%的数据划分出去，作为测试集，取不同的K值记录各K值下的分类正确率，取正确率高的作为最终K值。 KNN算法的步骤有了上述背景，我们可以简单的写出KNN算法步骤： 计算新入实例和各个训练样本的距离。 找到距离最小的K个实例。 统计这K个实例每个类别出现的次数。 将出现频率最高的类别记为新入实例的类别。 KNN算法的缺点KNN算法的优点有很多，其中最明显的一点是，这个算法逻辑简单，易于理解。他的缺点也不少，主要是有下面几个： 在样本数量不均衡时，KNN会偏向于数目更多的类别。举个例子，小亮的爸爸是黑社会，他有58个同班同学都是根正苗红的社会主义好青年，按照KNN算法小亮大概率被归为模范少年，但是这并不符合事实。 KNN算法需要进行繁重的距离计算：每来一个新的样本都要和所有样本进行一次距离计算，这在训练集很大的时候，会严重影响计算速度。 KNN算法需要存储所有训练样本，利用起来不方便。 总结写到这里，KNN的核心思想及算法步骤已经全部讲解完毕。这是一个非常简单，理解起来很容易的算法。但是这并不是KNN的所有内容，为了解决KNN的各种缺陷，市面上有一系列的KNN改进算法，比如：通过引入权值来把距离考虑在内的；将训练集分组减小计算量的；使用KD树减少距离计算次数的。这些都属于KNN进阶版本的算法了，我将另开一篇文章对这些内容进行通俗易懂的解释。 最后，本人水平有限，机器学习也是才入门的水平，难免有谬误，欢迎大家指正。 ReferenceCAWI2016-行为识别课程2-机器学习-K最近邻分类PPT]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>机器学习-原理讲解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树-基本原理]]></title>
    <url>%2F2017%2F11%2F11%2Fdecision-tree%2F</url>
    <content type="text"><![CDATA[一个事物内部会存在随机性，也就是不确定性，而从外部消除这个不确定性唯一的办法是引入信息。——吴军《数学之美》 什么是决策树生活中人们其实常常在潜意识中用到该模型，只不过大家没意识到而已。 比如，新学期伊始，AB两人在宿舍里开始了闲谈： A：咱们这学期选什么课啊，听学长说吉江老师的课挺好的，要不咱们一起上？ B：好啊，吉江课好过嘛 A：好过的，据说给分还挺高的。 B：那有考试吗？ A：没有考试，只用交5个实验报告就好。 B：作业呢？ A：不多，只用交实验报告，而且还是按组交的，组内要是有大神，嘿嘿嘿。 B：那是不是平时分特别多啊，压力会不会很大。 A：不会不会，吉江一天到晚往国内跑拉项目，就上六次课，压力约等于零。 B：那好啊，咱一起上吧。 这里B同学的决策逻辑就是一个典型的决策树，我们可以用下图表示。可以看到，决策树其实就是一个用来做决策的树形结构。 正式的来定义一下决策树其实就是： 是一个树形结构（二叉树或者多叉树） 非叶结点（长方形）代表一个特征 分支（箭头）代表输出 叶节点（圆形）代表决策结果 决策树的优点 非常简单，简单到你怀疑这到底是不是机器学习算法。 非常通俗易懂，看到树就明白是怎么回事了。 如何造树我们通过分析上图，能够提出两个问题：为什么B同学认为容不容易过，有没有考试，作业多不多，这三个要素是选择一门课的关键？以及为什么B同学为什么按照考试，作业，压力的顺序来进行提问。 正式点说就是：选取什么特征作为结点，以及用什么样的顺序来进行判断。这两点会成为构造决策树的关键。 决策树的构造首先，我想明确一点：选取什么特征和给特征排序其实是一个问题。这个问题就是，什么特征，最为关键重要，最能左右我的决策。排序越靠后的特征，代表越不关键，越不能左右我的决定。既然如此，我就也没有必要将其加在决策树中了。 所以说，归根结底，我们只用解决一个问题：哪几个特征最能左右我的决策？这看上去是一个公说公有理婆说婆有理的问题，但是，恰好，我们有一个用来量化表示左右决策程度的量——信息熵增益。 通过简单的比较信息熵增益的大小，就可以判断出到底哪个特征更加重要。不过在介绍它之前，我需要先说明信息熵以及条件熵到底是什么。 信息熵熵这个概念并不是我们第一次接触了，早在高中时代我们就接触过热力学的熵，如果我没有记错的话，熵是一个用来描述物质/系统混乱程度的物理量，熵越高，越混乱。类似的，信息熵是一个描述随机变量的不确定性的物理量，信息熵越大，不确定性越高，信息量越少。不确定性和混乱度，这两组概念是多么像啊，难怪命名为信息熵。 设X是一个有限取值的离散随机变量，其概率分布为：$$P(X=x_i)=P_i,i=1,2,3…n$$ 则随机变量X的信息熵定义如下： $$H(X)=-\sum_{i=1}^{n}p_i \times log(p_i)$$ 这里我不想解释信息熵为什么定义成这个样子，这会牵扯很多和机器学习不相关的领域。我只想说明一下为什么这个式子可以用来表述不确定性，以及对于决策树来说不确定性为什么这么重要。 对于一个二元分类来说，即n=2的情况下，信息熵的定义式可以写成如下形式： $$H(X)=-p \times log(p)-(1-p) \times log(1-p)$$ 我们可以将H(X)理解为一个关于概率p的函数，其函数图像如下（摘自百度百科）： 上文说过，信息熵H代表的是不确定性，H越大不确定性越大，信息量越小。若我们将上图的P理解为明天是晴天的概率，那么1-P代表的就是是明天不是晴天的概率。P=0就意味着明天百分百不是晴天，不确定性为0，所以P=0时H=0。同样的P=1时，意味着明天百分百是晴天，不确定性也为0，所以P=1时H=0。在P=0.5时，意味着我们对于明天是不是晴天毫无概念，不知道明天会是什么天，也不能像P=0.6时，得出明天很有可能是晴天的结论，我们仅仅知道我们一无所知。此时不确定性最大，信息量最小，所以H也在P=0.5时取到了最大值。 由此可见，信息熵的变化就代表了不确定性的变化。而决策树的构造过程其实就一个不断引入信息来降低不确定性的过程，每引入一个特征都会使得信息熵产生一定程度的减小，而熵减小的程度就代表了特征的重要性，这个熵减小的程度就是信息熵增益。 条件熵为了计算信息熵增益，首先要计算条件熵： 条件熵H(Y|X)表示在已知随机变量X的条件下，随机变量Y的不确定性。$$H(X|Y)=-\sum_{x\in X,y\in Y}P(x|y) \times log(x|y)$$换种说法就是，引入特征X后，随机变量Y的不确定性。 信息熵增益可以看到，我们现在可以计算随机变量Y原本的不确定性，还可以计算引入特征X后的不确定性，那么我们简单的将两式子相减就可以得到引入特征X后，不确定性减少的程度，也就是信息熵增益。其表达式如下：$$g(Y,X)=H(Y)-H(Y|X)$$ 构建决策树有了熵，条件熵，和信息熵增益的概念，构建决策树就是一件非常简单的事情了。首先计算原始熵，然后计算引入各个特征之后的条件熵，分别算出每个特征的信息熵增益，将增益最大的特征放在第一个判断结点。重复上述步骤，直到没有特征剩余，决策树就构建完成了，非常简单。 例子现在各大社交网络上充斥着各种僵尸粉，我们能否通过构造决策树来判断一个账号是否真实存在呢？通过人工浏览，我们获取了十个账号的信息，包括日志密度，好友密度，是否使用真实头像并对其真实性进行了人工标注，信息如下： 其中s，m和l分别代表小，中，大。 设L、F、H和R表示日志密度、好友密度、是否使用真实头像和账号是否真实。下面计算各属性的信息增益。 首先计算原始熵： $$H(R)= -0.7 \times log(0.7)-0.3 \times log(0.3)=0.7\times0.51+0.3\times1.74=0.879$$ 然后计算引入日志密度后的条件熵：$$H(L|R)=0.3\times(-\frac{1}{3}log\frac{1}{3}-\frac{2}{3}log\frac{2}{3})+0.4\times(-\frac{1}{4}log\frac{1}{4}-\frac{3}{4}log\frac{3}{4})+0.3\times(-\frac{0}{3}log\frac{0}{3}-\frac{3}{3}log\frac{3}{3})=0.602$$上式分为三部分，账号日志密度为s的概率为3/10=0.3，在此条件下，账号为真的概率为1/3，假的概率为2/3，可以得到上式第一部分。日志密度为l和m时同理。 计算日志密度的熵增益：$$gain(L,R)=H(R)-H(L|R)=0.879-0.602=0.277$$计算另一个特征好友密度的条件熵：$$\begin{align}H(F|R)=0.4\times(-\frac{1}{4}log\frac{1}{4}-\frac{3}{4}log\frac{3}{4})+ \ 0.4\times(-\frac{0}{4}log\frac{0}{4}-\frac{4}{4}log\frac{4}{4})+ \0.2\times(-\frac{0}{2}log\frac{0}{2}-\frac{2}{2}log\frac{2}{2})=0.325\end{align}$$计算其熵增益：$$gain(F,R)=H(R)-H(F|R)=0.879-0.325=0.554$$计算最后一个特征真实头像的条件熵：$$H(H|R)=0.5\times(-\frac{2}{5}log\frac{2}{5}-\frac{3}{5}log\frac{3}{5})+0.5\times(-\frac{1}{5}log\frac{1}{5}-\frac{4}{5}log\frac{4}{5})=0.846$$计算其熵增益：$$gain(H,R)=H(R)-H(H|R)=0.879-0.846=0.023$$可以看到，三个熵增益中，好友密度的熵增益最大，因此将其放在第一个判断结点。之后重复上面的三个步骤，确定后两个特征的顺序，即可构造出整棵决策树。 结语写到这里，决策树的基本思想就已经全部介绍完毕了。但是这并不是决策树的所有内容，按照上述方法构造出来的决策树还有很多的提升空间，比如说剪枝来预防过拟合问题，或者引入信息增益比的概念来解决信息增益准则对于可取值数目较多的属性有所偏好的问题。这都属于决策树的进阶技巧了，我将另开一篇文章对其进行通俗易懂的解释。对于最基本的决策树，我想说上述计算过程其实是一种极大似然估计，至于什么是极大似然估计让我们在下一篇文章《线性回归与逻辑回归》中见。 最后，本人水平有限，机器学习也是才入门的水平，难免有谬误，欢迎大家指正。 ReferenceCAWI2016-行为识别课程2-机器学习-决策树分类PPT 算法杂货铺——分类算法之决策树（Decision Tree） 数学之美]]></content>
      <categories>
        <category>学习心得</category>
      </categories>
      <tags>
        <tag>机器学习-原理讲解</tag>
      </tags>
  </entry>
</search>
